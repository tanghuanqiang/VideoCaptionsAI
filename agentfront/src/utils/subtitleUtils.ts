import type { Subtitle } from '../types/subtitleTypes';

export const parseTime = (time: string | number): number => {
    if (typeof time === 'number') return time;
    if (!time || typeof time !== 'string') return 0;
    
    const parts = time.split(':');
    const seconds = parseFloat(parts[parts.length - 1]);
    const minutes = parts.length > 1 ? parseInt(parts[parts.length - 2]) : 0;
    const hours = parts.length > 2 ? parseInt(parts[parts.length - 3]) : 0;
    
    return hours * 3600 + minutes * 60 + seconds;
};

export const formatTime = (seconds: number): string => {
    if (!seconds || isNaN(seconds)) return "00:00:00.00";
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 100);
    return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
};

export const findAvailableLayer = (subtitles: Subtitle[], start: number, end: number): number => {
    let layer = 0;
    while (true) {
        const hasOverlap = subtitles.some(sub => {
            if ((sub.layer || 0) !== layer) return false;
            const subStart = parseTime(sub.start);
            const subEnd = parseTime(sub.end);
            // Check overlap: not (end <= subStart || start >= subEnd)
            // Using a small epsilon for float comparison safety if needed, but strict inequality is usually fine for time ranges
            return !(end <= subStart || start >= subEnd);
        });
        
        if (!hasOverlap) {
            return layer;
        }
        layer++;
    }
};

export const calculateLayers = (subtitles: Subtitle[]): Subtitle[] => {
    // Sort by start time
    const sorted = [...subtitles].sort((a, b) => parseTime(a.start) - parseTime(b.start));
    
    // Track end times for each layer
    const layerEndTimes: number[] = [];
    
    return sorted.map(sub => {
        const start = parseTime(sub.start);
        const end = parseTime(sub.end);
        
        let assignedLayer = -1;
        
        // Find the first layer where this subtitle fits
        for (let i = 0; i < layerEndTimes.length; i++) {
            if (layerEndTimes[i] <= start) {
                assignedLayer = i;
                break;
            }
        }
        
        // If no layer found, create a new one
        if (assignedLayer === -1) {
            assignedLayer = layerEndTimes.length;
            layerEndTimes.push(end);
        } else {
            layerEndTimes[assignedLayer] = end;
        }
        
        return {
            ...sub,
            layer: assignedLayer
        };
    });
};

export const toSRT = (subtitles: Subtitle[]): string => {
    return subtitles.map((sub, index) => {
        const start = sub.start.replace('.', ',');
        const end = sub.end.replace('.', ',');
        return `${index + 1}\n${start} --> ${end}\n${sub.text}\n`;
    }).join('\n');
};

export const toASS = (subtitles: Subtitle[], styles: any[], playResX: number, playResY: number): string => {
    const header = `[Script Info]
; Script generated by VideoCaptionsAI
ScriptType: v4.00+
PlayResX: ${playResX}
PlayResY: ${playResY}
WrapStyle: 0
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
${styles.map(s => `Style: ${s.Name},${s.Fontname},${s.Fontsize},${s.PrimaryColour},${s.SecondaryColour},${s.OutlineColour},${s.BackColour},${s.Bold},${s.Italic},${s.Underline},${s.StrikeOut},${s.ScaleX},${s.ScaleY},${s.Spacing},${s.Angle},${s.BorderStyle},${s.Outline},${s.Shadow},${s.Alignment},${s.MarginL},${s.MarginR},${s.MarginV},${s.Encoding}`).join('\n')}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

    const events = subtitles.map(sub => {
        // Convert time format 00:00:00.00 to 0:00:00.00
        const formatAssTime = (t: string) => {
            const parts = t.split(':');
            const h = parseInt(parts[0]);
            return `${h}:${parts[1]}:${parts[2]}`;
        };
        
        return `Dialogue: ${sub.layer || 0},${formatAssTime(sub.start)},${formatAssTime(sub.end)},${sub.style || 'Default'},,0,0,0,,${sub.text}`;
    }).join('\n');

    return header + events;
};

export const downloadFile = (content: string, filename: string, type: string) => {
    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
};
